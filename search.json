[{"title":"nodejs学习笔记","url":"/2024/12/09/nodejs学习笔记/","content":"\n\n\n\n\n# NodeJS\n\n### 项目结构\t\n\n\n\n```javascript\nnpm init [-y]               // 生成package.json\nnpm install [--save] module  //save表示写入到package.json的dependencies中\n//npm 5.0版本以后不需要再加 --save，它会自动写入package.json\nnpm uninstall module\n```\n- package-lock.json作用：\n\n  1.加快模块下载速度\n  2.锁定模块版本，防止重新安装模块的时候自动更新成最新版\n\n- 设置响应头\n\n```javascript\n# writeHead会把服务器自动创建的set-cookie给替换掉\n# setHeader不会，它会增加一个set-cookie，设置了几个就增加几个\nres.writeHead(200,\n    {\n        \"Content-Type\":\"text/plain\",\n        \"set-cookie\":\"user=lienrong\"\n    }).end()\n\nres.setHeader(\"Content-Type\",\"application/json\").end()\n//cookie添加多个值\nres.setHeader(\"set-cookie\",[\"info_1\"=\"userinfo\",\"info_2\"=\"cartinfo\"])\n```\n\n\n\n- return的使用\n\n```javascript\nreturn   //终止当前函数的运行，并把return的值赋值给函数。使用return可以有效减少else的使用\n```\n\n\n\n- 常用第三方模块\n\n```javascript\nexpress\nart-template\nexpress-art-template   //express框架下的渲染引擎\nexpress-session\nbody-parser\t//解析post请求体\nnodemon   //调试时自动重启服务\nmongoose  //操作MongoDB\nmysql\nmd5\t\n```\n\n\n- 导出文件的方法、属性供外部访问\n\n```javascript\n//module存储形式\nmodule = {\n    exports: { x:\"x\",xx:\"xx\",xxx:\"xxx\"},\n    aaa: \"\",\n    bbb:\"\"   \n    ...\n    ...\n}\n//文件默认代码\nexports = module.exports\t\n\nexports.xx = xx\t\t\t//导出单个\nmodule.exports = {}\t\t//导出多个\nmodule.exports = xxx\t//只导出一个\n```\n\n\n\n### MongoDB数据库\n\n```javascript\n//数据存储格式\n//集合 -文档\n//集合是数组，文档是一个一个的对象\n{\n    students:[\n        {},\n        {},\n        {}\n    ],\n    teachers:[\n        {},\n        {}\n    ],\n   ...\n    ...\n\n}\n```\n\n```javascript\n/**\n * 该文件专门用来连接MongoDB，并创建不同的集合\n */\nvar mongoose = require(\"mongoose\")\nvar schema = mongoose.Schema\n//连接数据库\nmongoose.connect(\"mongodb://localhost:27017/eduSystem\")\n\n//设定集合结构和每个属性的约束条件\n//{ 约束1，约束2...}是一种设计约束的格式\nvar studentsSchema = new schema({\n    id:{\n        type:Number,\n        required:true\n    },\n    name:{\n        type:String,\n        required:true\n    },\n    sex:{\n        type:String,\n        required:true\n    },\n    age:{\n        type:Number,\n        required:true\n    },\n    country:{\n        type:String,\n        required:true\n\n    }\n}\n)\nvar teacherSchema = new schema({\n\n    id:{\n        type:Number,\n        required:true\n    },\n    email:{\n        type:String,\n        required:true\n    },\n    password:{\n        type:String,\n        required:true\n    },\n    create_time:{\n        type:Date,\n        default:Date.now\n    }\n})\n\n//创建teachers集合（类似数据表）\nvar teachers = mongoose.model(\"Teacher\",teacherSchema)\n\n//创建students集合\nvar students = mongoose.model(\"Student\",studentsSchema)\n\n//必须写在最后，否则router中无法识别findOne之类的方法\nmodule.exports = {\n    \"students\":students,\n    \"teachers\":teachers\n}\n```\n\n```javascript\n// 添加数据，每条数据是个对象\n// 只能一个一个添加，不能一次性添加多个，会报错？\nvar a = new Kitten(\n    {username:\"中国人\",password:1234}\n)\na.save(function (err,data){\n    if (err){\n        console.log(err)\n    }\n    else{\n        console.log(\"sucess\")\n    }\n})\n\n//查询全部数据,返回数组\nKitten.find(function (err,result){\n    if (err){\n        \n    }else{\n        console.log(result)\n    }\n})\n\n//按条件查询，返回数组\nKitten.find({password:1234},function (err,result){\n    if (err){\n\n    }else {\n        console.log(result)\n    }\n})\n\n//返回的是对象\nKitten.findOne({password:1234},function (err,result){\n    if (err){\n\n    }else {\n        console.log(result)\n    }\n})\n\n//按条件删除数据\nKitten.deleteOne({password:1234},function (err){\n    if (err){\n\n    }else {\n        console.log(\"sucess\")\n    }\n\n})\n\n//更新一条数据，第一个参数是查询条件，第二个参数是要修改数据中的哪个值\nKitten.findOneAndUpdate({password:23},{password:1234},function (err){\n    if (err){\n\n    }else {\n        console.log(\"sucess\")\n    }\n})\n```\n\n\n\n### 使用express框架\n\n- 启动服务器\n\n```javascript\nvar express = require(\"express\")\nvar app = express()\napp.listen(port,function (){\n\n})\n```\n- ##### 路由分离与设计\n\n  app.js\n\n```javascript\nvar router = require(\"./router.js\")\napp.use(router) //挂载路由\n```\n​      router.js   ---作用只有一个，对不同url做不同处理\n```javascript\nvar express = require(\"express\")\nvar router = express.Router()  //创建路由\nmodule.exports=router //导出路由\n\nrouter.get(\"/\",function (req,res,next){\n\n})\nrouter.post(\"/\",function (req,res,next){\n\n})\n......\n```\n​\t路由设计\n\n| 路径    | 请求类型 | get参数 | post参数                | 是否需要登录 | 备注               |\n| ------- | -------- | ------- | ----------------------- | ------------ | ------------------ |\n| /login  | get      |         |                         |              | 获取登录页面       |\n| /login  | post     |         | email、password         |              | 提交”登录“表单     |\n| /create | get      |         |                         | 是           | 获取添加学生页面   |\n| /create | post     |         | name、sex、age、country | 是           | 提交”添加学生“表单 |\n\n\n\n- 获取post请求的body\n\n```javascript\n//使用body-parser中间件\nvar bodyParser = require('body-parser')\napp.use(bodyParser.urlencoded({ extended: false }))\t//解析application/x-www-form-urlencoded。req.body含有\t\t\t\t\t\t\t\t\t\t\t\t\t  [Object: null prototype]\napp.use(bodyParser.urlencoded({ extended: true }))\t//req.body是标准对象\napp.use(bodyParser.json())  //解析application/json\nreq.body    //req.body是一个对象\n\n//不使用中间件\napp.use(express.json())\napp.use(express.urlencoded({extended:true}))\n```\n\n\n- 对外开放静态资源访问\n\n```javascript\napp.use(\"/public\",express.static(\"public\")) //访问url是 /public/xxx\napp.use(\"/aaa\",express.static(\"public\")) //访问url是 /aaa/xxx\napp.use(express.static(\"public\")) //访问url是 /xxx\n```\n#### art-template\n\n- express 中使用art-template\n\n```javascript\nnpm install --save art-template\nnpm install --save express-art-template\napp.engine(\"html\",require(\"express-art-template\"))\napp.set(\"views\",\"/xxx\")\t\t//修改默认寻找html的目录views\nres.render(\"index.html\",{\n    xxx:\"xxx\",\n    xxx:\"xxx\"\n})\t\n```\n\n- art-template页面继承与引用\n\n```html\n{{ extend \"./xxx.html\"}}   \n{{ block \"自定义的名字\"}}\n\t这里写自定义页面\n{{ /block }}\n{{ include ./xxx.html }} \n```\n\n- 模板语法\n\n```javascript\n//渲染\nres.render(\"index.html\",{\n                user:req.session.userinfo,\n                students:data\n          })\n\n//html中如果没有模板语法存在，可以直接返回html\n//html中如果有模板语法，省略第二个参数，可以直接忽略语法\nres.render(\"index.html\")\n```\n\n\n\n```html\n<!-- \nstudents是数组[\n\t\t\t\t{},\n\t\t\t\t{},\n\t\t\t\t{}\n\t\t  \t ]\n循环读取students，有几个对象就创建几个<tr>标签\n-->\n{{ each students }}\n                <tr>\n                  <td>{{ $value.id }}</td>\n                  <td>{{ $value.name }}</td>\n                  <td>{{ $value.sex }}</td>\n                  <td>{{ $value.age }}</td>\n                  <td>{{ $value.country }}</td>\n                  <td>\n                    <button><a href = \"/update?id={{ $value.id }}\">编辑</a></button>\n                    <button><a href = \"/del?id={{ $value.id }}\">删除</a></button>\n                  </td>\n              \n                </tr>\n{{ /each }}\n```\n\n```html\n<!-- \n如果user存在，那么展示第一个<ul>\n否则，展示第二个<ul>\n-->\n{{ if user }}\n           <ul class=\"nav navbar-nav navbar-right\">\n             <li><a href=\"\">欢迎您：</a></li>\n             <li><a href=\"\">{{ user.email }}</a></li>\n             <li><a href=\"/logout\">退出登录</a></li>\n           </ul>\n        {{ else }}\n           <ul class=\"nav navbar-nav navbar-right\">\n            <li><a href=\"/login\">登录</a></li>\n            <li><a href=\"/register\">注册</a></li>\n          </ul>\n {{ /if }}\n```\n\n\n\n- 回调\n\n```javascript\n//readFile中的function是一个回调函数，若想使用该函数里面的变量，\n//就要在该函数执行完成以后，把变量作为参数传递给外部的callback函数，\n//这时callback函数中参数就是需要的变量\nfunction list(callback){\n    fs.readFile(\"./db.json\",function (err,data){\n        students=JSON.parse(data).students\n        callback(students)\n    })\n}\n//调用list函数\nlist(function (x){\n    //x就是students\n})\n```\n```javascript\n//遍历\nfor (i in x){\n    consolo.log(i)\n}\n\n//x是数组时，i的值在执行的时候是索引下标\n//x是对象时，i的值在执行的时候是属性\n```\n\n\n\n- Promise对象\n\n1. 支持then链式语法，解决回调地狱\n\n2. 规定异步执行顺序\n\n   \n\n```javascript\nvar p1 = new Promise(function (resolve,reject){\n    fs.readFile(\"./router.js\",function (err,data){\n        var x = \"hello world\"\n        resolve(x) //x作为参数传递给resolve函数 \n    })\n})\n\np1\n    .then(function (data){  //这就是p1的resolve函数，data就是x\n        return 123  //把x传递给下个then的函数的参数\n    })\n    .then(function (a){ //a就是123\n        fs.readFile(\"./app.js\",function (err,data){\n            console.log(a+\"   hahaha\")\n        })\n    })\n```\n\n```javascript\nvar fs = require(\"fs\")\n\nvar p1 = new Promise(function (resolve,reject){\n    fs.readFile(\"./router.js\",function (err,data){\n        var x = \"hello world\"\n        resolve(x) //x作为参数传递给resolve函数\n        \n    })\n})\n\np1\n    .then(function (data){  //这就是p1的resolve函数，data就是x\n        return new Promise(function (resolve,reject){\n            fs.readFile(\"./router.js\",function (err,data){\n                var y = \"hello world\"+123\n                resolve(y) //y作为参数传递给resolve函数         \n            })\n        }) \n    })\n    .then(function (a){ //a就是y\n        fs.readFile(\"./app.js\",function (err,data){\n    \n            console.log(a+\"   hahaha\")\n        })\n    })\n```\n\n```javascript\n#\tthrow err不能放在then方法的异步函数中，要放在异步函数外面，否则catch捕获不到err\n#\tthen的异步函数结果想要传递给下个then，结果必须放在异步函数外面，因此必须使用promise，通过resolve传递\n\nnew Promise(function (resolve,reject){\n        connection.query(\"select * from teachers where email=?\",body.email,function (err,result){\n            if (err){\n                reject(err)\t\t//设为异常\n                return\n            }\n            resolve(result.length)\n        })\n    })\n    .then(function (length){\t\n        if (length !== 0){\t\t//判断user表中有无对应用户\n            res.json({\n                code:4,\n                message:\"用户已存在\"\n            })\n            return new Promise(function (){})   //不执行后面的then\n        }\n        return new Promise(function (resolve,reject){\t\t\n            connection.query(\"select * from teachers order by id desc limit 1\",function (err,result){\n                if (err){\n                    reject(err)\n                    return\n                }\n                if (result.length == 0){ \t//判断user表是否为空，为空新用户id设为1000，不为空新用户id是最后一个用\t\t\t\t\t\t\t\t\t\t\t\t户的id增加1\n                    newid = 1000\n                }else{\n                    newid = JSON.parse(JSON.stringify(result))[0].id + 1\n                } \n                resolve(newid)        //传递新用户的id给下个then\n            })\n        })    \n    })\n    .then(function (newid){\n            connection.query(\"insert into teachers values(?,?,?)\",[newid,body.email,body.password],\n            function (err,result){\n                if (err){\n                   \tnext(err)\n                    return \n                }\n                req.session.userinfo = {email:body.email}\n                res.json({\n                    code:-1,\n                    message:\"ok\"\n                })\n            })    \n    })\n    .catch(function (err){\t\t//捕获异常\n       next(err)\n    })\n```\n\n\n\n- ​\tasync await优化promise\n\n  ```javascript\n  # await会等待promise结果变为resolve，再执行后面的代码\n  async function myfun(){\n      await new Promise(function (resolve,reject){\n          //异步函数\n          resolve()\n      })\n      \n      //其他代码\n      \n      //把promise返回值赋值给x\n      var x = await new Promise(function (resolve,reject){\n          //异步函数\n          resolve()\n      })\n  }\n  //执行函数，并捕获异常\n  myfun().catch(function (err){\n      \n  })\n  ```\n\n  \n\n  \n\n- 动态获取绝对路径\n\n```javascript\nvar path = require(\"path\")\npath.join(\"\",\"\",\"\"......) //拼接成路径，拼接过程中自动加入\\或删除多余的\\\n\npath.resolve(__dirname, '..') //返回当前目录的上一级目录\n#path还有其他API，请查看文档\n\n//注意以下两个属性前面有两条下划线\n__dirname  //动态获取当前文件所在的目录的绝对路径\n__filename //动态获取当前文件的绝对路径\n\n\nfs.readFile(\"./db.json\",\"utf8\",function (err,data)\n#当执行node所处的目录不是xxx.js所处的目录时，使用相对路径会报错\n#所有的针对文件的读写等操作（包括对外开放静态资源）都不要使用相对路径，而要使用__dirname和__filename来动态获取绝对路径\n#但是require引用的文件要用相对路径，它不受执行node所处目录影响\n```\n\n\n\n- art-template页面继承与引用\n\n\n```html\n{{ extend \"./xxx.html\"}}   \n{{ block \"自定义的名字\"}}\n\t这里写自定义页面\n{{ /block }}\n{{ include ./xxx.html }} \n```\n\n\n\n- ##### 表单同步提交和异步提交\n\n- 同步提交\n  - 页面结果由服务器处理\n  - 页面会刷新\n  \n  ```html\n  <form action=\"url\" method=\"get/post\">\n      .....\n      .....\n      .....\n  <button type=\"submit\">提交</button>\n  </form>\n  ```\n  \n  \n  \n- 异步提交\n  - 服务器只返回数据，客户端通过ajax，接受数据，根据不同数据对页面做不同处理\n  - 服务器对页面的处理不会生效\n  - 页面不会刷新\n  - 页面想要跳转请使用window.location.href=\"xxx\"\n\n```javascript\n/**\n 1.html引入jquery库\n 2.引用外部js文件\n 3.去掉form标签的action和method属性\n 4.button的type属性改为button\n */\n//第一种方式，不定义函数，直接调用js，监听指定元素的点击事件，发送ajax请求\n$(document).ready(function (){\n  $(\"#login_btn\").on(\"click\",function (){\n    $.ajax({\n      type:\"post\",\n      url:\"/login\",\n      data:$(\"#form\").serialize(), //获取form表单数据\n      success:function (data){\n        if(data.result == -1){\n          window.alert(data.message)\n        }else if(data.result == 0){\n          window.location.href = \"/\"\n        }else{\n          window.alert(data.message)\n        }\n      }\n    })\n  })\n})\n\n//第二种方式,定义函数，触发了html事件后，调用函数发送ajax请求\n//html中button添加事件onclick=\"login()\"\nfunction login(){\n  $.ajax({\n    type:\"post\",\n    url:\"/login\",\n    data:$(\"#form\").serialize(),\n    success:function (data){\n      if(data.result == -1){\n        window.alert(data.message)\n      }else if(data.result == 0){\n        window.location.href = \"/\"\n      }else{\n        window.alert(data.message)\n      }\n    }\n  })\n}\n```\n\n\n\n- API\n\n```javascript\nres.status(404).end() //设置http响应代码\nres.json({result:0,message:\"ok\"})\t//自动调用JSON.stringify()把参数转为json字符串，响应头的Content-Type设置为application/json\n```\n\n\n\n- #### express框架本身不支持session，需要使用第三方session模块\n\n  ##### 原理\n\n  1. 客户端发送登录请求，用户名密码校验通过后，服务器创建session，并把session存储到内存或者数据库\n  2. 服务器自动添加响应头set-cookie=sessionID\n  3. 客户端收到set-cookie响应，设置cookie\n  4. 客户端以后的每次请求都会在请求头中发送cookie\n  5. 服务器拿到cookie中的sessionID，到session存储介质中进行检索，如果找到，会把session中存储的数据（一般是用户信息）赋值给 req.session；如果找不到，req.session无值\n  6. 服务器通过req.session是否有值来判断用户是否已登录\n\n  session何时清除\n\n  3. 主动调用destroy（）方法清除\n  4. 内存中的session，服务器进程终止后清除\n  3. 通过session存储介质设置的expires自动清除session\n\n\n```javascript\nnpm install express-session\nvar session = require(\"express-session\")\n\n# session默认存储到内存\n# cookie的maxAge同时也影响session的expires\n# cookie的maxAge优先于介质中设置的expires，同时都有设置的时候，session的expires取决于maxAge\n\n//存储到MongoDB\nnpm install connect-mongo\nvar MongoStore = require (\"connect-mongo\")\napp.use(session(\n    {\n \t   secret: 'keyboard cat', //自定义字符串，hash计算得到T，放在cookie中，防止cookie被篡改\n       resave: false,\n       cookie:{maxAge:60000}, //设置cookie有效时间，单位是ms，cookie过期后，后续请求就不携带Cooke了\n       saveUninitialized: false,\t //只要客户端来请求，就自动生成一个session\n       store:MongoStore.create({\n           mongoUrl: 'mongodb://localhost:27017/eduSystem'\n           ttl:1209600\t//设置session expires\n       })  //session存储到MongoDB\n   }\n))\n\n//存储到mysql\nvar MysqlStore = require(\"express-mysql-session\")\nvar options = {\n    host:\"192.168.199.100\",\n    port:3306,\n    user:\"root\",\n    password:\"7758521\",\n    database:\"eduSystem\",\n    expiration: 86400000,    //session存储时效，单位ms，session只是过期，不会清除\n    clearExpired:true,\t\t//是否清除过期session\n    checkExpirationInterval:120000\t//每隔多长时间清除一次过期session\n}\nvar sessionStore = new MysqlStore(options)\napp.use(session(\n    {\n        secret:\"osdsjyp012\",\n        resave:false,\n        saveUninitialized:false,\n        store:sessionStore\n    }\n))\n\n//用户登录时创建session，会自动在响应头中添加set-cookie = sessionID\n//用户登录后，后续向session中添加数据\nreq.session.yourSessionName = yourSessionValue\n\n\n//销毁服务器session\nreq.session.destroy()\n\n//退出登录状态,服务器session还在\nreq.session.yourSessionName = null\n```\n\n\n\n- 使用第三方模块md5加密\n\n```javascript\nnpm install md5\nvar md5 = require(\"md5\")\nmd5passwod = md5(body.password)\n```\n\n\n\n- 异步请求时，服务器对页面的更改、跳转无效\n\n\n\n#### Express中间件\n\n1. ##### 中间件是按照代码顺序依次执行的\n\n2. ##### 请求经过中间件时，如果中间件中没有调用next()，则请求会停留在这个中间件中；如果有调用next()，则请求会继续去匹配下个中间件，但是它只会去匹配符合规定条件的中间件\n\n3. ##### 中间件实际上接受3个参数function（req,res,next），next是个函数\n\n1. 应用程序级别中间件\n\n   ```javascript\n   //万能匹配 任何请求都会经过这里\n   app.use(function (){\n   \t[next()]    \n   })\n   //只匹配以/xxx开头的去请求\n   app.use(\"/xxx\",function (){\n       \n   })\n   ```\n\n2. 路由级别中间件\n\n   ```javascript\n   //严格匹配，规定了请求方法和请求路径。只有符合的请求才会经过这里\n   app.get(\"url\",function (){\n       \n   })\n   app.post(\"url\",function (){\n       \n   })\n   app.put(...)\n   ...\n   ```\n\n3. 错误处理中间件\n\n   ```javascript\n   //必须接受4个参数\n   app.use(function (err,req,res,next){\n        res.status(500).send(err)\n   })\n   //使用\n   app.get(\"url\",function (req,res,next){\n     \t...\n       ...\n       if (err){\n      \t\treturn next(err)  \n   \t}  \n       ...\n       ...\n   })\n   \n   ```\n\n4. 内置中间件\n\n   express.static\n\n5. 第三方中间件\n\n   body-parser\n\n   session\n\n- express自定义处理404\n\n```javascript\n//必须放在挂载路由后面，原因是中间件的执行顺序\napp.use(function (req,res){         \n    res.status(404).send(\"404页面找不到\")\n})\n```\n\n\n\n res.header(\"Access-Control-Allow-Origin\", \"*\")//允许跨域请求\n\n#### 前后端分离\n\n- 浏览器请求页面或者需要页面跳转的时候，请求的是前端服务器，前端服务器再去请求后台服务器接口，拿到返回的数据，然后渲染页面\n- 浏览器发起ajax请求的时候，如果不需要页面跳转，可以直接请求后台服务器，拿到返回的数据，在ajax里对本页面进行渲染\n\n\n\n\n\n//设置跨域访问  \n\n```javascript\napp.all('*', function(req, res, next) {  \n\n    res.header(\"Access-Control-Allow-Origin\", \"*\");  \n\n    //res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");  \n\n    //res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\");  \n\n    // res.header(\"X-Powered-By\",' 3.2.1')  \n\n    //res.header(\"Content-Type\", \"application/json;charset=utf-8\");  \n    \n    res.header('Access-Control-Allow-Credentials', \"true\");//允许跨域设置cookie\n\n    next();  \n\n}); \n//ajax中设置跨域访问cookie\nxhrFields:{\n            withCredentials:true\n        },\n```\n\n使用https协议\n\n```javascript\n//使用openssl生成私钥、证书签名、证书\n# openssl genrsa 1024 >./private.pem\n# openssl req -new -key ./private.pem -out csr.pem\n# openssl x509 -req -days 365 -in csr.pem -signkey ./private.pem -out ./file.crt\n\n//服务器中使用https\nvar https = require(\"https\")\nvar privateKey = fs.readFileSync(path.join(__dirname,\"https/private.pem\"),\"utf8\")\nvar certificate = fs.readFileSync(path.join(__dirname,\"https/file.crt\"),\"utf8\")\nvar credentials = {key:privateKey,cert:certificate}\n\nvar httpsServer = https.createServer(credentials,app)\nhttpsServer.listen(3000,function (){\n    console.log(\"server started at https://127.0.0.1:3000\")\n})\n```\n\nsql注入\n\n```javascript\n//只有使用字符串拼接才会出现sql注入漏洞\nconnection.query(\"select * from teachers where email='\" + body.email + \"'\",function (err,result){})\n\n//防止sql注入\n#使用占位符\nconnection.query(\"select * from teachers where email=?\",body.email,function (err,result){})\nconnection.query(\"select * from teachers where email=? and password=?\",[body.email,body.password],function (err,result){})\n#使用escape方法对参数编码，变量两边没有引号\nconnection.query(\"select * from teachers where email=\" + connection.escape(body.email),function (err,result){})\n```\n\n\n\n安装xmysql，支持postman使用api操作数据库\n\nhttps://www.npmjs.com/package/xmysql\n\n```javascript\nnpm install xmysql\n//开启xmysql服务\nxmysql -h 192.168.199.100 -u root -p 7758521 -d eduSystem\n//访问地址\nlocalhost:3000\n```\n\n\n\n","tags":["nodejs","代码"],"categories":["技术"]},{"title":"使用hexo框架创建个人博客","url":"/2024/12/08/使用hexo框架创建个人博客/","content":"\n\n\n1、安装nodejs，git\n\n2、安装hexo\n\n```javascript\nnpm install -g hexo-cli\n```\n\n3、新建文件夹作为博客目录，例如D:/myblog\n\n4、初始化目录\n\n```javascript\nhexo init myblog\n```\n\n5、启动hexo，访问地址http://localhost:4000\n\n```javascript\ncd myblog\nhexo s\n```\n\n6、部署到github\n\n```javascript\ngit config --global user.name \"github_name\"\ngit config --global user.email \"github_email\"\n\nssh-keygen -t rsa -C \"github_email\"  //创建ssh密钥文件\n\n```\n\n登录github，点击 New  SSH  key\n\n```\nssh -T git@github.com  //测试连接是否成功\n```\n\n修改 _config.yml\n\n```\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: 'git'\n  repo: https://github.com/github_name/github_name.github.io\n  branch: main\n```\n\n```javascript\nnpm install hexo-deployer-git //安装deployer插件\n\nhexo cl\nhexo d  //部署\n```\n\n","tags":["安装","hexo"],"categories":["技术"]}]